<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pensieve Water Background Video Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #000;
      color: #fff;
      font-family: monospace;
    }
    #canvas-container {
      width: 1920px;
      height: 1080px;
      margin: 20px auto;
      border: 2px solid #333;
      background: #000;
    }
    .controls {
      max-width: 1920px;
      margin: 0 auto;
      padding: 20px;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      background: #0071e3;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #0077ed;
    }
    button:disabled {
      background: #555;
      cursor: not-allowed;
    }
    .status {
      margin: 10px 0;
      padding: 10px;
      background: #222;
      border-radius: 5px;
    }
    .progress {
      width: 100%;
      height: 20px;
      background: #333;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-bar {
      height: 100%;
      background: #0071e3;
      width: 0%;
      transition: width 0.3s;
    }
  </style>
</head>
<body>
  <div class="controls">
    <h1>Pensieve Water Background Video Generator</h1>
    <div class="status" id="status">Ready to generate video</div>
    <div class="progress" id="progress-container" style="display: none;">
      <div class="progress-bar" id="progress-bar"></div>
    </div>
    <div>
      <button id="start-btn" onclick="startRecording()">Start Recording (10 seconds)</button>
      <button id="stop-btn" onclick="stopRecording()" disabled>Stop Recording</button>
      <button id="download-btn" onclick="downloadVideo()" disabled>Download Video</button>
    </div>
    <div style="margin-top: 20px;">
      <label>
        Width: <input type="number" id="width" value="1920" min="640" max="3840">
      </label>
      <label style="margin-left: 20px;">
        Height: <input type="number" id="height" value="1080" min="360" max="2160">
      </label>
      <label style="margin-left: 20px;">
        Duration (seconds): <input type="number" id="duration" value="10" min="1" max="60">
      </label>
    </div>
  </div>
  <div id="canvas-container"></div>

  <script>
    // Simplex 3D 노이즈 GLSL 구현
    const simplexNoise = `
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;

        i = mod289(i);
        vec4 p = permute(permute(permute(
                  i.z + vec4(0.0, i1.z, i2.z, 1.0))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);

        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }
    `;

    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const fragmentShader = `
      ${simplexNoise}

      uniform float uTime;
      uniform vec2 uResolution;
      uniform vec2 uMouse;
      uniform float uMouseStrength;
      uniform vec2 uMouseVel;
      uniform vec3 uColorDeep;
      uniform vec3 uColorMid;
      uniform vec3 uColorLight;
      uniform vec3 uColorHighlight;

      varying vec2 vUv;

      mat2 rotate2d(float angle){
        return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
      }

      float fbm(vec2 p) {
        float value = 0.0;
        float amplitude = 0.5;
        float frequency = 0.8;
        mat2 rot = rotate2d(0.5);
        
        for(int i = 0; i < 4; i++) {
          value += amplitude * snoise(vec3(p * frequency, uTime * 0.05));
          p = rot * p * 2.0 + vec2(uTime * 0.02);
          amplitude *= 0.5;
        }
        return value;
      }

      float domainWarp(vec2 p) {
        vec2 q = vec2(
          fbm(p + vec2(0.0, 0.0)),
          fbm(p + vec2(5.2, 1.3))
        );
        
        vec2 r = vec2(
          fbm(p + 4.0 * q + vec2(1.7, 9.2)),
          fbm(p + 4.0 * q + vec2(8.3, 2.8))
        );
        
        return fbm(p + 4.0 * r);
      }

      void main() {
        vec2 uv = vUv;
        vec2 aspect = vec2(uResolution.x / uResolution.y, 1.0);
        vec2 uvAspect = (uv - 0.5) * aspect;
        
        float distFromCenter = length(uvAspect);
        
        float angle = atan(uvAspect.y, uvAspect.x);
        float radius = length(uvAspect);
        
        float swirlStrength = 1.5;
        float swirlAngle = angle + swirlStrength / (radius + 0.2) * sin(uTime * 0.1);
        
        vec2 swirledUV = vec2(cos(swirlAngle), sin(swirlAngle)) * radius;
        
        vec2 mouseUV = (uMouse - 0.5) * aspect;
        vec2 toMouse = uvAspect - mouseUV;
        float mouseDist = length(toMouse);
        
        float influence = exp(-mouseDist * 20.0) * uMouseStrength;
        
        vec2 pushDir = normalize(toMouse + vec2(1e-4));
        vec2 perp = vec2(-pushDir.y, pushDir.x);
        vec2 velAspect = uMouseVel * aspect;
        float velMag = clamp(length(velAspect) * 10.0, 0.0, 1.0);

        vec2 interactiveUV = swirledUV;
        interactiveUV -= pushDir * influence * 0.05; 
        interactiveUV -= velAspect * influence * 0.06;
        interactiveUV += perp * influence * 0.9 * velMag;

        float fluid = domainWarp(interactiveUV * 2.4 - vec2(0.0, uTime * 0.045));

        float ripple = sin(mouseDist * 20.0 - uTime * 0.75) * exp(-mouseDist * 5.0) * influence;
        fluid += ripple * 0.03;

        fluid -= influence * 0.9;

        float localTurb = snoise(vec3(interactiveUV * 6.0, uTime * 0.6)) * influence;
        fluid += localTurb * 0.18;
        
        vec3 color = mix(uColorDeep, uColorMid, smoothstep(0.1, 0.5, fluid));
        color = mix(color, uColorLight, smoothstep(0.4, 0.8, fluid));
        
        float highlight = smoothstep(0.75, 1.0, fluid);
        color = mix(color, uColorHighlight, highlight * 0.8);
        
        color *= smoothstep(0.5, 0.2, distFromCenter);
        color *= 1.3;
        
        float softMask = smoothstep(0.5, 0.35, distFromCenter);
        vec3 finalColor = mix(uColorDeep, color, softMask);
        
        float bgNoise = snoise(vec3(uv * 5.0, uTime * 0.05)) * 0.02;
        finalColor += bgNoise * (1.0 - softMask);

        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    let scene, camera, renderer, material, mesh;
    let mediaRecorder;
    let recordedChunks = [];
    let startTime = 0;
    let animationId;

    function init() {
      const container = document.getElementById('canvas-container');
      const width = parseInt(document.getElementById('width').value);
      const height = parseInt(document.getElementById('height').value);
      
      container.style.width = width + 'px';
      container.style.height = height + 'px';

      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
      camera.position.z = 1;

      renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
        powerPreference: 'high-performance'
      });
      renderer.setPixelRatio(1); // 고정 해상도로 녹화
      renderer.setSize(width, height);
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      const deepColor = new THREE.Color('#082026');
      const midColor = new THREE.Color('#165B6B');
      const lightColor = new THREE.Color('#78BCCF');
      const highlightColor = new THREE.Color('#E0F7FA');

      material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          uTime: { value: 0 },
          uResolution: { value: new THREE.Vector2(width, height) },
          uMouse: { value: new THREE.Vector2(0.5, 0.5) },
          uMouseStrength: { value: 0 },
          uMouseVel: { value: new THREE.Vector2(0, 0) },
          uColorDeep: { value: deepColor },
          uColorMid: { value: midColor },
          uColorLight: { value: lightColor },
          uColorHighlight: { value: highlightColor }
        },
        transparent: true,
        depthTest: false,
        depthWrite: false
      });

      const geometry = new THREE.PlaneGeometry(2, 2);
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      animate();
    }

    function animate() {
      animationId = requestAnimationFrame(animate);
      
      if (startTime > 0) {
        const timeElapsed = (Date.now() - startTime) / 1000;
        material.uniforms.uTime.value = timeElapsed;
      }
      
      renderer.render(scene, camera);
    }

    function startRecording() {
      const width = parseInt(document.getElementById('width').value);
      const height = parseInt(document.getElementById('height').value);
      const duration = parseInt(document.getElementById('duration').value);

      // Canvas를 MediaStream으로 변환
      const canvas = renderer.domElement;
      const stream = canvas.captureStream(30); // 30 FPS

      recordedChunks = [];
      startTime = Date.now();

      // MediaRecorder 설정
      const options = {
        mimeType: 'video/webm;codecs=vp9',
        videoBitsPerSecond: 8000000 // 8 Mbps
      };

      // WebM이 지원되지 않으면 H.264 시도
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        options.mimeType = 'video/webm;codecs=vp8';
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'video/webm';
        }
      }

      mediaRecorder = new MediaRecorder(stream, options);

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };

      mediaRecorder.onstop = () => {
        updateStatus('Recording stopped. Processing video...');
        processVideo();
      };

      mediaRecorder.start();
      
      document.getElementById('start-btn').disabled = true;
      document.getElementById('stop-btn').disabled = false;
      document.getElementById('download-btn').disabled = true;
      document.getElementById('progress-container').style.display = 'block';
      
      updateStatus(`Recording... (${duration} seconds)`);
      
      // 자동으로 duration 후에 중지
      setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          stopRecording();
        }
      }, duration * 1000);
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        document.getElementById('stop-btn').disabled = true;
      }
    }

    function processVideo() {
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      
      // 비디오를 다운로드 가능하게 만들기
      window.videoBlob = blob;
      window.videoUrl = url;
      
      document.getElementById('download-btn').disabled = false;
      updateStatus('Video ready! Click Download to save.');
      document.getElementById('progress-container').style.display = 'none';
    }

    function downloadVideo() {
      if (window.videoBlob) {
        const a = document.createElement('a');
        a.href = window.videoUrl;
        a.download = 'pensieve-water-background.webm';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        updateStatus('Video downloaded!');
      }
    }

    function updateStatus(message) {
      document.getElementById('status').textContent = message;
    }

    // 초기화
    window.addEventListener('load', () => {
      init();
    });
  </script>
</body>
</html>
